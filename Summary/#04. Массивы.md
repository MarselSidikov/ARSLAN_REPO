# Массивы

* Массив - структура данных, представляющая собой набор элементов, каждый из которых доступен по его порядковому номеру (индексу).

* Массив - набор переменных, где имя каждой переменной -> имя_массива[индекс]

* Индексы в Java идут с 0, поэтому если массив имеет длину 10, то самый первый элемент будет иметь индекс - 0, последний - 9.

* Объявление массива в Java

```JAVA
int array[] = new int[10];
```

## Сортировка массива

- Для чего нужна сортировка?

Пусть у нас есть массив:

```
3 8 9 11 -5 66 -2 6 101 -3
```

Необходимо в этом элементе найти число 101, как это сделать?

```
Последовательно перебрать все элементы массива, найти элемент. Всего -> 9 операций.
```

А если мы осортируем массив по возрастанию?

```
-5 -3 -2 3 6 8 9 11 66 101
```

Как теперь искать?

```
1) Посмотрим центральный элемент, это -> 6, 6 больше или меньше 101? Меньше, следовательно надо искать в правой половине.
2) Смотрим центральный элемент правой половины -> 11, 11 больше или меньше 101? Меньше, следовательно надо искать в правой половине.
3) Смотрим центральный элемент правой половины -> 66, 66 больше или меньше 101? Меньше, смотрим справа -> а там уже 101.
Всего операций -> 3
```

Сортировка сильно ускоряет операцию последущего поиска. 

## Сортировка выбором

Пусть дан массив:

```
3 8 9 11 -5 66 -2 6 101 -3
```

Найдем минимальный элемент:

```
-5
```

Заменим его с элементом, который стоит на первом месте, получим следующий массив:

```
-5 8 9 11 3 66 -2 6 101 -3
```

Теперь массив начинается с самого маленького элемента. Забудем про него, и будем искать минимум в другом диапазоне:

```
-5 [8 9 11 3 66 -2 6 101 -3]
```

Тут минимум:

```
-3
```

Заменим этот элемент со вторым:

```
-5 -3 9 11 3 66 -2 6 101 8
```

повторяем процесс ...

### Формальное описание алгоритма:

```
Пусть есть неупорядоченный массив A = a[0], a[1], .. a[N-1]

ПОКА не прошли весь массив
	min -> min(a[i], a[N-1])
	a[i] <-> min
	i++
```


## Бинарный поиск (см. выше)

Суть алгоритма -> в отсортированном массиве находить центральный элемент и выбирать половину, в которой может находится искомый элемент. Далее, для выбранной половины повторить алгоритм.